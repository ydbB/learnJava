<center>sychronized底层是怎么实现？什么是锁的升级，降级？</center>
问题16：synchronized底层如何实现？什么是锁的升级，降级？
### 典型回答  
synchronized代码块是由一对monitorenter/monitorexit 指令来实现的，Monitor对象是同步的基本的单位。  
在java 6 之前，Monitor的实现完全是依赖操作系统内部的互斥锁来实现，因为需要进行用户态和内核态切换，所以同步操作是一个重操作。  
现代的JDK中，JVM提供了三种不同的Monitor锁，偏斜锁，轻量级锁，重量级锁，大大改进了其性能。  
所谓的锁升级，降级，就是JVM优化synchronized的运行机制，当JVM检测到不同的竞争状态时，会自动切换到合适的锁实现，这种切换也就是所谓的升级，降级。  
当没有竞争的时候，默认使用的时偏斜锁，JVM会利用CAS操作，在对象头上的Mark Word部分设置线程ID，以表示这个对象偏向这个线程，没有涉及真正的互斥锁。　　
如果有另外的线程试图锁定某个已经被偏向过的对象，JVM就需要撤销偏斜锁，并切换到轻量级锁，轻量级依赖CAS操作Mark　Word来试图获取锁；如果切换到轻量级，就使用普通的轻量级锁；否则进一步升级为重量级锁。　　
锁的降级也会发生,当JVM进入安全点的时候,会检查是否闲置的Monitor,然后似乎图进行降级.
### 考点分析
主要考察对Java锁实现的掌握,也是并发的基本题目.
对于这部分的掌握,可以分析:
* 从源码层面,对synchronized底层实现有所了解;
* 理解并发包中java.util.concurent.Lock提供的其他锁实现.
